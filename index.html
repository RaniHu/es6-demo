<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

<script>
    window.onload = function () {

        /* 
            es6 总结
            ECMAScript 是 js的规格，js是es的一种实现，es6为5.1版本以后的js下一代标准
         */

        // test();
        // test2();
        // test3();



        /* 一.变量let和const */

        //  1.var关键字
        // (1)var声明变量，无论声明在何处，都被视为声明在函数最顶部，这就是函数变量提升
        // (2)var声明的变量，函数作用域，即作用域为声明变量的语句所在的函数内

        //  以下两个函数相等
        function test() {
            if (0 > 1) {
                var texts = "abc";
            } else {
                console.log(texts); //undefined
            }
        }

        function test2() {
            var texts; //变量提升
            if (0 > 1) {
                texts = 'abc';
            } else {
                console.log(texts); //undefine
            }
            //这里再访问texts也是undefined
        }

        // 2. let声明变量，块级作用域，不存在变量提升，也不允许重复声明，必须声明之后再引用，否则报错
        //(1) 块级的意思为：声明只在一个函数内部，或声明所在的代码块内有效    
        function test3() {
            if (0 > 1) {
                let texts = "123"; //let作用域在它所在当前代码块(花括号),不会被提升到函数顶部
            } else {
                console.log(texts); //此处无法访问test，发生错误未定义
            }
        }

        for (let j = 0; j < 10; j++) {
            // console.log(j);                                   //输出0到9
        }
        // console.log(j);                                       //报错


        //(2)不存在变量提升，即变量必须声明之后才能使用
        // console.log(foo);                                     //报错
        let foo = 1;


        //(3)暂时性死区,使用let命令声明变量之前，该变量是不可用的，语法上称为暂时性死区
        var temp = 123;
        if (true) {
            // temp='abc';                                         //报错，使用let声明，在声明之前都属于x的死区
            let temp;
        }

        // typeof(x);                                              //报错
        let x;

        typeof undeclared; //未声明的变量反而不会报错


        //(4)不允许重复声明
        function declareFn() {
            // let a=0;
            // let a=10;
        }

        function params(arg) {
            //let arg;                                            //不允许在函数内部重新声明参数
        }

        function params2(arg) {
            {
                let arg;
            }
        }








        //example1
        var funcs = [];

        //i是var声明的，全局有效，每一次循环i会发生变化，被赋值给funcs的函数内部console.log(i)。所有数组funcs中的成员里的i都指向同一个i，即最后一个10
        for (var i = 0; i < 10; i++) {
            funcs.push(function () {
                console.log(i); //每个数组项都是一个方法，输出十次10
            })
        }
        funcs.forEach(function (func) {
            func();
        })

        //example2
        const funcArr = [];

        //i是let声明的，i只在本轮循环中有效，每次循环i都是一个新的变量
        for (let i = 0; i < 10; i++) {
            funcArr.push(function () {
                console.log(i); //输出0-9
            })
        }
        funcArr.forEach(func => func());

        //example2
        //for循环中，设置变量的部分是父作用域，循环体内是单独的子作用域，两个i有不同的作用域
        for (let i = 0; i < 3; i++) {
            let i = 'abc';
            console.log(i); //输出三次abc
        }






        //3. const
        //(1)声明一个基本类型时为常量，只能在声明时赋值，不可随意修改
        const name = 'rita';
        // name='joy';                                             //再次赋值时报错

        // const foo;                                              //报错，const一旦声明变量就要立即初始化，不能之后再赋值

        //(2)当const为一个对象时，对象所包含的值可以被修改，因为保存的是一个指针，对象所指向的地址没有改变（并不是变量的值不能改动，而是变量指向的那个内存地址不能改动）
        const student = {
            name: 'linda'
        }
        student.name = 'lily';

        //常量foos存储的是一个地址，这个地址指向一个对象。这个地址不可变，即不能把foo指向另一个地址，但对象本身是可变的，可为其添加属性。
        const foos = {};
        foos.prop = 123;
        foos.prop; //123 

        //错误，直接修改了对象
        // student={
        //     name:'aaa'
        // }

        //(3)const声明的变量也不可提升，不可重复声明，只在块级作用域中有效



        //4、块级作用域
        //(1)为什么要使用？

        //防止变量提升，内层变量可能会覆盖外层变量
        var date = new Date();

        function f() {
            //var date变量提升
            console.log(date); //undefined
            if (false) {
                // var date='hello';
            }
        }
        f();

        function blockFn() {
            let n = 5;
            if (true) {
                let n = 10; //此n只在if代码块内有效
            }
            console.log(n); //5
        }



        //5.顶层对象的属性
        //(1)顶层对象，在浏览器中指的是window对象，es6规定var和function声明的全局变量依旧是顶层对象的属性
        //(2)let，const，class声明的全局变量，不属于全局对象的属性

        var vars = 1;
        console.log(window.vars); //1

        let bars = 2;
        console.log(window.bars); //undefined


        //二、模板字符串
        //1.字符串格式化，将表达式嵌入字符串进行拼接

        //es5
        var first = '123';
        var last = '789';
        var yourname = 'linda' + first + last;
        console.log('your name is ' + yourname);

        //es6
        console.log(`my name is ${first} ${last}`);
        console.log(`http://localhost:3000/api/messages/${first}`);


        //2.多行字符串使用 ``

        //es5
        var roadPoem = 'Then look the other, as just' +
            'this is the end';

        //es6 
        var roadPoems = `Then look the other, as just the end`;


        //三、函数
        //1.默认参数
        function link(height = 50, color = 'red', url = 'www.baidu.com') {
            console.log(url);
        }

        //2.箭头函数
        //(1)函数的快捷写法：不需要function关键字创建函数；省略return关键字；继承当前上下问的this关键字

        [1, 2, 3, 4].map(x => x + 1);

        //等同于
        [1, 2, 3, 4].map((function (x) {
            return x + 1;
        }).bind(this));



        //(2)当函数只有一个参数时，可以省略括号；当函数返回仅有一个表达式时可以省略{}和return

        var people = name => 'hello' + name                           //name为参数，后面为return之后的语句

        var people2 = (name, age) => {                               //两个参数括号不可省略
            const fullname = 'hello' + name;
            return fullname;
        }

        var ids = ['123434', '234234234', '3423423'];
        console.log(ids.map(value => `ID is ${value}`));
        console.log(ids.map((value, index) => `ID of ${index} element is ${value}`));      //两个参数括号不可省略


        //(3)箭头函数中this还是原来的this

        //es5
        var _this = this;
        // document.querySelector("#btn").click(function(){
        //     _this.sendData();
        // })

        //es6 
        // document.querySelector("#btn").click((event)=>{
        //     this.sendData();
        // })



        //四、对象的拓展
        //1.es6省略冒号和function关键字
        const person = {
            name: 'lua',
            getName() {
                console.log(this.name);
            }
        }

        //2.Object.assign(目标对象，源1，源2)浅复制，把任意多个源对象可枚举的属性拷贝给目标对象，返回目标对象。

        //实际项目中，为了不改变源对象，一般把目标对象传为{}
        const objA = {
            name: 'lucy',
            age: 20
        };
        const objB = {
            address: 'Shanghai'
        }
        const obj = Object.assign({}, objA, objB);
        console.log(obj);                                          //{name: "lucy", age: 20, address: "Shanghai"}



        //五、解构
        //es6新增解构，可以将数组或对象分解为更小的部分(从数组和对象中提取值，对变量进行复制，称为解构)


        //1.数组解构
        //(1)等号两边的模式相同，左边变量就会被赋予对应的值
        let [a, b, c] = [1, 2, 3];

        //(2)不完全解构，左边只匹配一部分等号右边的数组，仍可以解构成功
        let [m, n] = [1, 2, 3];
        console.log(m);
        console.log(n);

        //(3)等号右边不是数组(不是可遍历的结构)，将会报错
        // let [bar] = false;
        // let [bar] = 1;
        // let [bar] = {};



        //2.对象的属性没有次序，变量必须与属性同名
        //es5
        const person2 = {
            name: 'linda',
            age: 23
        }
        const age = people2.age;

        //es6
        const person3 = {
            names: 'ina',
            ages: 22
        }
        const { names, ages } = person3;
        const { name2, age2 } = {
            name2: "aaa",
            age2: 20
        }
        console.log(`${names}-----${ages}`);
        console.log(`${name2}-----${age2}`);


        //3.字符串的解构赋值
        //(1)字符串被转换成了类似数组的对象
        const [j,k,l] = 'hello';
        j;                             //h
        k;                             //e
        l;                             //l

        //(2)类似数组的对象都有一个length属性
        let { length: len } = 'hello';
        len;                           //5



        //六、展开运算符...
        //1.组装数组 
        const color = ['red', 'blue'];
        const colourful = [...color, 'green', 'pink'];
        console.log(colourful);                                //['red','blue','green','pink']

        //2.组装对象
        const alp = { fist: 'a', second: 'b' }
        const alphabets = { ...alp, third: 'c' }
        console.log(alphabets)                                  //{ "fist": "a", "second": "b", "third": "c"

        //3.获取前几项或某几项

        //数组
        const numbers = [1, 2, 3, 4, 5];
        const [first2, ...rest] = numbers;
        console.log(rest);                                      //2,3,4,5

        //对象
        const user = {
            username: 'lux',
            gender: 'female',
            age: 19,
            address: 'peking'
        }
        const {username,...rests}=user;        
        console.log(rests);                                     // { gender: 'female',age: 19,address: 'peking'}

        //对象组合，如果属性名重复，右边覆盖左边
        const first3={
            a:1,
            b:2,
            c:3
        }

        const second={
            c:3,
            d:5
        }
        const total={...first3,...second};
        console.log(total);
        console.log(second);


        //七、import和export
        //1.export导入模块
        //(1)如果希望外部能够读取模块(一个独立的文件)内部的某个变量。就必须使用关键字export输出该变量


        //八、promise对象
        //1.promise是异步编程的一种解决方案，es6将其写进了语言标准，统一了语法，原生提供了promise对象
        //2.promise就是一个容器，里面保存着未来才会结束的事件。promise是一个对象，从它可以获取异步操作的消息

        /*3.promise的特点
        (1)对象的状态不受外界影响。
           promise对象代表一个异步操作，有三种状态: pending进行中、fulfilled已成功和rejected已失败，只有异步的操作结果，可以决定当前是哪种状态。
        (2)一旦状态改变，就不会再变。
           promise的状态只有两种,pending变为fulfilled，pending变为rejected，只要两种情况发生，状态就凝固了，不会再变，这时称为resolved(已定型)      
        */

         /*4.promise优点
         (1) 有了promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套函数(可读性差，耦合度高，扩展性低) 
         (2) promise对象提供统一的接口，控制异步操作更加容易   
         */

         /*5.promise缺点
         (1) 无法取消promise，一旦建立就会立即执行，无法中途取消。
         (2) 如果不设置回调函数，promise内部抛出的错误，不会反应到外部
         (3) 处于pending状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)
         */

         //6.基本用法
         //(1)promise对象是一个构造函数，用来生成promise实例。
         //   resovle函数将promise对象状态从“未完成”到“成功”，在异步操作成功时调用，并将异步操作结果作为参数传递出去。
         //   reject函数将promise对象状态从“未完成”到“失败”，在异步调用失败时，将异步操作报出的错误，作为参数传递出去。
         const promise=new Promise(function(resolve,reject){
             if(true){
                resolve(value);
             }else{
                 reject(error);
             }
         })

         //(2)promise实例生成后，可以用then方法分别指定成功和失败状态的回调函数
         //   then方法接受两个回调函数作为参数(resolved和rejected)，第二个函数是可选的
         promise.then(function(value){
            //成功后执行的操作
         },function(error){
            //失败后执行的操作
         })

         //example
         function timeout(ms){
             return new Promise(function(resolve,reject){
                 setTimeout(resolve,ms,'done');
             })
         }

         timeout(2000).then((value)=>{
             console.log(value);
         })
    

        















    }
</script>

</html>